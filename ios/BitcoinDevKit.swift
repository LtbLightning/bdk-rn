// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(bdkFFI)
import bdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bdk_1cc_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bdk_1cc_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
fileprivate class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        self.offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset..<offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value, { data.copyBytes(to: $0, from: range)})
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> Array<UInt8> {
        let range = offset..<(offset+count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer({ buffer in
            data.copyBytes(to: buffer, from: range)
        })
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
fileprivate class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        self.bytes = []
        self.offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: Writer)
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    static func lift(_ buf: RustBuffer) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    static func lower(_ value: SwiftType) -> RustBuffer {
          let writer = Writer()
          write(value, into: writer)
          return RustBuffer(bytes: writer.bytes)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    static func read(from buf: Reader) throws -> UInt8 {
        return try lift(buf.readInt())
    }

    static func write(_ value: UInt8, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    static func read(from buf: Reader) throws -> UInt32 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: Reader) throws -> UInt64 {
        return try lift(buf.readInt())
    }

    static func write(_ value: SwiftType, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    static func read(from buf: Reader) throws -> Float {
        return try lift(buf.readFloat())
    }

    static func write(_ value: Float, into buf: Writer) {
        buf.writeFloat(lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: Reader) throws -> Bool {
        return try lift(buf.readInt())
    }

    static func write(_ value: Bool, into buf: Writer) {
        buf.writeInt(lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: Reader) throws -> String {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: Writer) {
        let len = Int32(value.utf8.count)
        buf.writeInt(len)
        buf.writeBytes(value.utf8)
    }
}


public protocol AddressProtocol {
    func `scriptPubkey`()  -> Script
    
}

public class Address: AddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`address`: String) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_Address_new(
        FfiConverterString.lower(`address`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_Address_object_free(pointer, $0) }
    }

    

    
    public func `scriptPubkey`()  -> Script {
        return try! FfiConverterTypeScript.lift(
            try!
    rustCall() {
    
    bdk_1cc_Address_script_pubkey(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Address

    static func read(from buf: Reader) throws -> Address {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: Address, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Address {
        return Address(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: Address) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol BlockchainProtocol {
    func `broadcast`(`psbt`: PartiallySignedTransaction) throws
    func `getHeight`() throws -> UInt32
    func `getBlockHash`(`height`: UInt32) throws -> String
    
}

public class Blockchain: BlockchainProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`config`: BlockchainConfig) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_Blockchain_new(
        FfiConverterTypeBlockchainConfig.lower(`config`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_Blockchain_object_free(pointer, $0) }
    }

    

    
    public func `broadcast`(`psbt`: PartiallySignedTransaction) throws {
        try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Blockchain_broadcast(self.pointer, 
        FfiConverterTypePartiallySignedTransaction.lower(`psbt`), $0
    )
}
    }
    public func `getHeight`() throws -> UInt32 {
        return try FfiConverterUInt32.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Blockchain_get_height(self.pointer, $0
    )
}
        )
    }
    public func `getBlockHash`(`height`: UInt32) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Blockchain_get_block_hash(self.pointer, 
        FfiConverterUInt32.lower(`height`), $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeBlockchain: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Blockchain

    static func read(from buf: Reader) throws -> Blockchain {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: Blockchain, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Blockchain {
        return Blockchain(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: Blockchain) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol BumpFeeTxBuilderProtocol {
    func `allowShrinking`(`address`: String)  -> BumpFeeTxBuilder
    func `enableRbf`()  -> BumpFeeTxBuilder
    func `enableRbfWithSequence`(`nsequence`: UInt32)  -> BumpFeeTxBuilder
    func `finish`(`wallet`: Wallet) throws -> PartiallySignedTransaction
    
}

public class BumpFeeTxBuilder: BumpFeeTxBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`txid`: String, `newFeeRate`: Float)  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    bdk_1cc_BumpFeeTxBuilder_new(
        FfiConverterString.lower(`txid`), 
        FfiConverterFloat.lower(`newFeeRate`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_BumpFeeTxBuilder_object_free(pointer, $0) }
    }

    

    
    public func `allowShrinking`(`address`: String)  -> BumpFeeTxBuilder {
        return try! FfiConverterTypeBumpFeeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_BumpFeeTxBuilder_allow_shrinking(self.pointer, 
        FfiConverterString.lower(`address`), $0
    )
}
        )
    }
    public func `enableRbf`()  -> BumpFeeTxBuilder {
        return try! FfiConverterTypeBumpFeeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_BumpFeeTxBuilder_enable_rbf(self.pointer, $0
    )
}
        )
    }
    public func `enableRbfWithSequence`(`nsequence`: UInt32)  -> BumpFeeTxBuilder {
        return try! FfiConverterTypeBumpFeeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_BumpFeeTxBuilder_enable_rbf_with_sequence(self.pointer, 
        FfiConverterUInt32.lower(`nsequence`), $0
    )
}
        )
    }
    public func `finish`(`wallet`: Wallet) throws -> PartiallySignedTransaction {
        return try FfiConverterTypePartiallySignedTransaction.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_BumpFeeTxBuilder_finish(self.pointer, 
        FfiConverterTypeWallet.lower(`wallet`), $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeBumpFeeTxBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BumpFeeTxBuilder

    static func read(from buf: Reader) throws -> BumpFeeTxBuilder {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: BumpFeeTxBuilder, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BumpFeeTxBuilder {
        return BumpFeeTxBuilder(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: BumpFeeTxBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol DerivationPathProtocol {
    
}

public class DerivationPath: DerivationPathProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`path`: String) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_DerivationPath_new(
        FfiConverterString.lower(`path`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_DerivationPath_object_free(pointer, $0) }
    }

    

    
    
}


fileprivate struct FfiConverterTypeDerivationPath: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DerivationPath

    static func read(from buf: Reader) throws -> DerivationPath {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: DerivationPath, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DerivationPath {
        return DerivationPath(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: DerivationPath) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol DescriptorPublicKeyProtocol {
    func `derive`(`path`: DerivationPath) throws -> DescriptorPublicKey
    func `extend`(`path`: DerivationPath) throws -> DescriptorPublicKey
    func `asString`()  -> String
    
}

public class DescriptorPublicKey: DescriptorPublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_DescriptorPublicKey_object_free(pointer, $0) }
    }

    
    public static func `fromString`(`publicKey`: String) throws -> DescriptorPublicKey {
        return DescriptorPublicKey(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_DescriptorPublicKey_from_string(
        FfiConverterString.lower(`publicKey`), $0)
})
    }
    

    
    public func `derive`(`path`: DerivationPath) throws -> DescriptorPublicKey {
        return try FfiConverterTypeDescriptorPublicKey.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_DescriptorPublicKey_derive(self.pointer, 
        FfiConverterTypeDerivationPath.lower(`path`), $0
    )
}
        )
    }
    public func `extend`(`path`: DerivationPath) throws -> DescriptorPublicKey {
        return try FfiConverterTypeDescriptorPublicKey.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_DescriptorPublicKey_extend(self.pointer, 
        FfiConverterTypeDerivationPath.lower(`path`), $0
    )
}
        )
    }
    public func `asString`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    bdk_1cc_DescriptorPublicKey_as_string(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeDescriptorPublicKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorPublicKey

    static func read(from buf: Reader) throws -> DescriptorPublicKey {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: DescriptorPublicKey, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorPublicKey {
        return DescriptorPublicKey(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: DescriptorPublicKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol DescriptorSecretKeyProtocol {
    func `derive`(`path`: DerivationPath) throws -> DescriptorSecretKey
    func `extend`(`path`: DerivationPath) throws -> DescriptorSecretKey
    func `asPublic`()  -> DescriptorPublicKey
    func `secretBytes`()  -> [UInt8]
    func `asString`()  -> String
    
}

public class DescriptorSecretKey: DescriptorSecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`network`: Network, `mnemonic`: Mnemonic, `password`: String?)  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    bdk_1cc_DescriptorSecretKey_new(
        FfiConverterTypeNetwork.lower(`network`), 
        FfiConverterTypeMnemonic.lower(`mnemonic`), 
        FfiConverterOptionString.lower(`password`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_DescriptorSecretKey_object_free(pointer, $0) }
    }

    
    public static func `fromString`(`secretKey`: String) throws -> DescriptorSecretKey {
        return DescriptorSecretKey(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_DescriptorSecretKey_from_string(
        FfiConverterString.lower(`secretKey`), $0)
})
    }
    

    
    public func `derive`(`path`: DerivationPath) throws -> DescriptorSecretKey {
        return try FfiConverterTypeDescriptorSecretKey.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_DescriptorSecretKey_derive(self.pointer, 
        FfiConverterTypeDerivationPath.lower(`path`), $0
    )
}
        )
    }
    public func `extend`(`path`: DerivationPath) throws -> DescriptorSecretKey {
        return try FfiConverterTypeDescriptorSecretKey.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_DescriptorSecretKey_extend(self.pointer, 
        FfiConverterTypeDerivationPath.lower(`path`), $0
    )
}
        )
    }
    public func `asPublic`()  -> DescriptorPublicKey {
        return try! FfiConverterTypeDescriptorPublicKey.lift(
            try!
    rustCall() {
    
    bdk_1cc_DescriptorSecretKey_as_public(self.pointer, $0
    )
}
        )
    }
    public func `secretBytes`()  -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
    rustCall() {
    
    bdk_1cc_DescriptorSecretKey_secret_bytes(self.pointer, $0
    )
}
        )
    }
    public func `asString`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    bdk_1cc_DescriptorSecretKey_as_string(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeDescriptorSecretKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DescriptorSecretKey

    static func read(from buf: Reader) throws -> DescriptorSecretKey {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: DescriptorSecretKey, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DescriptorSecretKey {
        return DescriptorSecretKey(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: DescriptorSecretKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol FeeRateProtocol {
    func `asSatPerVb`()  -> Float
    
}

public class FeeRate: FeeRateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_FeeRate_object_free(pointer, $0) }
    }

    
    public static func `fromSatPerVb`(`satPerVb`: Float)  -> FeeRate {
        return FeeRate(unsafeFromRawPointer: try!
    
    rustCall() {
    
    bdk_1cc_FeeRate_from_sat_per_vb(
        FfiConverterFloat.lower(`satPerVb`), $0)
})
    }
    

    
    public func `asSatPerVb`()  -> Float {
        return try! FfiConverterFloat.lift(
            try!
    rustCall() {
    
    bdk_1cc_FeeRate_as_sat_per_vb(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeFeeRate: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    static func read(from buf: Reader) throws -> FeeRate {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: FeeRate, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol MnemonicProtocol {
    func `asString`()  -> String
    
}

public class Mnemonic: MnemonicProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`wordCount`: WordCount)  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    bdk_1cc_Mnemonic_new(
        FfiConverterTypeWordCount.lower(`wordCount`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_Mnemonic_object_free(pointer, $0) }
    }

    
    public static func `fromString`(`mnemonic`: String) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_Mnemonic_from_string(
        FfiConverterString.lower(`mnemonic`), $0)
})
    }
    
    public static func `fromEntropy`(`entropy`: [UInt8]) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_Mnemonic_from_entropy(
        FfiConverterSequenceUInt8.lower(`entropy`), $0)
})
    }
    

    
    public func `asString`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    bdk_1cc_Mnemonic_as_string(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeMnemonic: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mnemonic

    static func read(from buf: Reader) throws -> Mnemonic {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: Mnemonic, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mnemonic {
        return Mnemonic(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: Mnemonic) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol PartiallySignedTransactionProtocol {
    func `serialize`()  -> String
    func `txid`()  -> String
    func `extractTx`()  -> [UInt8]
    func `combine`(`other`: PartiallySignedTransaction) throws -> PartiallySignedTransaction
    func `feeAmount`()  -> UInt64?
    func `feeRate`()  -> FeeRate?
    
}

public class PartiallySignedTransaction: PartiallySignedTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`psbtBase64`: String) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_PartiallySignedTransaction_new(
        FfiConverterString.lower(`psbtBase64`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_PartiallySignedTransaction_object_free(pointer, $0) }
    }

    

    
    public func `serialize`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    bdk_1cc_PartiallySignedTransaction_serialize(self.pointer, $0
    )
}
        )
    }
    public func `txid`()  -> String {
        return try! FfiConverterString.lift(
            try!
    rustCall() {
    
    bdk_1cc_PartiallySignedTransaction_txid(self.pointer, $0
    )
}
        )
    }
    public func `extractTx`()  -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
    rustCall() {
    
    bdk_1cc_PartiallySignedTransaction_extract_tx(self.pointer, $0
    )
}
        )
    }
    public func `combine`(`other`: PartiallySignedTransaction) throws -> PartiallySignedTransaction {
        return try FfiConverterTypePartiallySignedTransaction.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_PartiallySignedTransaction_combine(self.pointer, 
        FfiConverterTypePartiallySignedTransaction.lower(`other`), $0
    )
}
        )
    }
    public func `feeAmount`()  -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(
            try!
    rustCall() {
    
    bdk_1cc_PartiallySignedTransaction_fee_amount(self.pointer, $0
    )
}
        )
    }
    public func `feeRate`()  -> FeeRate? {
        return try! FfiConverterOptionTypeFeeRate.lift(
            try!
    rustCall() {
    
    bdk_1cc_PartiallySignedTransaction_fee_rate(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypePartiallySignedTransaction: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PartiallySignedTransaction

    static func read(from buf: Reader) throws -> PartiallySignedTransaction {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: PartiallySignedTransaction, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PartiallySignedTransaction {
        return PartiallySignedTransaction(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: PartiallySignedTransaction) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol ScriptProtocol {
    
}

public class Script: ScriptProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`rawOutputScript`: [UInt8])  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    bdk_1cc_Script_new(
        FfiConverterSequenceUInt8.lower(`rawOutputScript`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_Script_object_free(pointer, $0) }
    }

    

    
    
}


fileprivate struct FfiConverterTypeScript: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Script

    static func read(from buf: Reader) throws -> Script {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: Script, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Script {
        return Script(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: Script) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol TxBuilderProtocol {
    func `addRecipient`(`script`: Script, `amount`: UInt64)  -> TxBuilder
    func `addUnspendable`(`unspendable`: OutPoint)  -> TxBuilder
    func `addUtxo`(`outpoint`: OutPoint)  -> TxBuilder
    func `addUtxos`(`outpoints`: [OutPoint])  -> TxBuilder
    func `doNotSpendChange`()  -> TxBuilder
    func `manuallySelectedOnly`()  -> TxBuilder
    func `onlySpendChange`()  -> TxBuilder
    func `unspendable`(`unspendable`: [OutPoint])  -> TxBuilder
    func `feeRate`(`satPerVbyte`: Float)  -> TxBuilder
    func `feeAbsolute`(`feeAmount`: UInt64)  -> TxBuilder
    func `drainWallet`()  -> TxBuilder
    func `drainTo`(`address`: String)  -> TxBuilder
    func `enableRbf`()  -> TxBuilder
    func `enableRbfWithSequence`(`nsequence`: UInt32)  -> TxBuilder
    func `addData`(`data`: [UInt8])  -> TxBuilder
    func `setRecipients`(`recipients`: [ScriptAmount])  -> TxBuilder
    func `finish`(`wallet`: Wallet) throws -> TxBuilderResult
    
}

public class TxBuilder: TxBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    bdk_1cc_TxBuilder_new($0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_TxBuilder_object_free(pointer, $0) }
    }

    

    
    public func `addRecipient`(`script`: Script, `amount`: UInt64)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_add_recipient(self.pointer, 
        FfiConverterTypeScript.lower(`script`), 
        FfiConverterUInt64.lower(`amount`), $0
    )
}
        )
    }
    public func `addUnspendable`(`unspendable`: OutPoint)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_add_unspendable(self.pointer, 
        FfiConverterTypeOutPoint.lower(`unspendable`), $0
    )
}
        )
    }
    public func `addUtxo`(`outpoint`: OutPoint)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_add_utxo(self.pointer, 
        FfiConverterTypeOutPoint.lower(`outpoint`), $0
    )
}
        )
    }
    public func `addUtxos`(`outpoints`: [OutPoint])  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_add_utxos(self.pointer, 
        FfiConverterSequenceTypeOutPoint.lower(`outpoints`), $0
    )
}
        )
    }
    public func `doNotSpendChange`()  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_do_not_spend_change(self.pointer, $0
    )
}
        )
    }
    public func `manuallySelectedOnly`()  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_manually_selected_only(self.pointer, $0
    )
}
        )
    }
    public func `onlySpendChange`()  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_only_spend_change(self.pointer, $0
    )
}
        )
    }
    public func `unspendable`(`unspendable`: [OutPoint])  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_unspendable(self.pointer, 
        FfiConverterSequenceTypeOutPoint.lower(`unspendable`), $0
    )
}
        )
    }
    public func `feeRate`(`satPerVbyte`: Float)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_fee_rate(self.pointer, 
        FfiConverterFloat.lower(`satPerVbyte`), $0
    )
}
        )
    }
    public func `feeAbsolute`(`feeAmount`: UInt64)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_fee_absolute(self.pointer, 
        FfiConverterUInt64.lower(`feeAmount`), $0
    )
}
        )
    }
    public func `drainWallet`()  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_drain_wallet(self.pointer, $0
    )
}
        )
    }
    public func `drainTo`(`address`: String)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_drain_to(self.pointer, 
        FfiConverterString.lower(`address`), $0
    )
}
        )
    }
    public func `enableRbf`()  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_enable_rbf(self.pointer, $0
    )
}
        )
    }
    public func `enableRbfWithSequence`(`nsequence`: UInt32)  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_enable_rbf_with_sequence(self.pointer, 
        FfiConverterUInt32.lower(`nsequence`), $0
    )
}
        )
    }
    public func `addData`(`data`: [UInt8])  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_add_data(self.pointer, 
        FfiConverterSequenceUInt8.lower(`data`), $0
    )
}
        )
    }
    public func `setRecipients`(`recipients`: [ScriptAmount])  -> TxBuilder {
        return try! FfiConverterTypeTxBuilder.lift(
            try!
    rustCall() {
    
    bdk_1cc_TxBuilder_set_recipients(self.pointer, 
        FfiConverterSequenceTypeScriptAmount.lower(`recipients`), $0
    )
}
        )
    }
    public func `finish`(`wallet`: Wallet) throws -> TxBuilderResult {
        return try FfiConverterTypeTxBuilderResult.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_TxBuilder_finish(self.pointer, 
        FfiConverterTypeWallet.lower(`wallet`), $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeTxBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TxBuilder

    static func read(from buf: Reader) throws -> TxBuilder {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: TxBuilder, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TxBuilder {
        return TxBuilder(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: TxBuilder) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol WalletProtocol {
    func `getAddress`(`addressIndex`: AddressIndex) throws -> AddressInfo
    func `getBalance`() throws -> Balance
    func `sign`(`psbt`: PartiallySignedTransaction) throws -> Bool
    func `listTransactions`() throws -> [TransactionDetails]
    func `network`()  -> Network
    func `sync`(`blockchain`: Blockchain, `progress`: Progress?) throws
    func `listUnspent`() throws -> [LocalUtxo]
    
}

public class Wallet: WalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`descriptor`: String, `changeDescriptor`: String?, `network`: Network, `databaseConfig`: DatabaseConfig) throws {
        self.init(unsafeFromRawPointer: try
    
    rustCallWithError(FfiConverterTypeBdkError.self) {
    
    bdk_1cc_Wallet_new(
        FfiConverterString.lower(`descriptor`), 
        FfiConverterOptionString.lower(`changeDescriptor`), 
        FfiConverterTypeNetwork.lower(`network`), 
        FfiConverterTypeDatabaseConfig.lower(`databaseConfig`), $0)
})
    }

    deinit {
        try! rustCall { ffi_bdk_1cc_Wallet_object_free(pointer, $0) }
    }

    

    
    public func `getAddress`(`addressIndex`: AddressIndex) throws -> AddressInfo {
        return try FfiConverterTypeAddressInfo.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Wallet_get_address(self.pointer, 
        FfiConverterTypeAddressIndex.lower(`addressIndex`), $0
    )
}
        )
    }
    public func `getBalance`() throws -> Balance {
        return try FfiConverterTypeBalance.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Wallet_get_balance(self.pointer, $0
    )
}
        )
    }
    public func `sign`(`psbt`: PartiallySignedTransaction) throws -> Bool {
        return try FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Wallet_sign(self.pointer, 
        FfiConverterTypePartiallySignedTransaction.lower(`psbt`), $0
    )
}
        )
    }
    public func `listTransactions`() throws -> [TransactionDetails] {
        return try FfiConverterSequenceTypeTransactionDetails.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Wallet_list_transactions(self.pointer, $0
    )
}
        )
    }
    public func `network`()  -> Network {
        return try! FfiConverterTypeNetwork.lift(
            try!
    rustCall() {
    
    bdk_1cc_Wallet_network(self.pointer, $0
    )
}
        )
    }
    public func `sync`(`blockchain`: Blockchain, `progress`: Progress?) throws {
        try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Wallet_sync(self.pointer, 
        FfiConverterTypeBlockchain.lower(`blockchain`), 
        FfiConverterOptionCallbackInterfaceProgress.lower(`progress`), $0
    )
}
    }
    public func `listUnspent`() throws -> [LocalUtxo] {
        return try FfiConverterSequenceTypeLocalUtxo.lift(
            try
    rustCallWithError(FfiConverterTypeBdkError.self) {
    bdk_1cc_Wallet_list_unspent(self.pointer, $0
    )
}
        )
    }
    
}


fileprivate struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    static func read(from buf: Reader) throws -> Wallet {
        let v: UInt64 = try buf.readInt()
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    static func write(_ value: Wallet, into buf: Writer) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        buf.writeInt(UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct AddressInfo {
    public var `index`: UInt32
    public var `address`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `address`: String) {
        self.`index` = `index`
        self.`address` = `address`
    }
}


extension AddressInfo: Equatable, Hashable {
    public static func ==(lhs: AddressInfo, rhs: AddressInfo) -> Bool {
        if lhs.`index` != rhs.`index` {
            return false
        }
        if lhs.`address` != rhs.`address` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`index`)
        hasher.combine(`address`)
    }
}


fileprivate struct FfiConverterTypeAddressInfo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> AddressInfo {
        return try AddressInfo(
            `index`: FfiConverterUInt32.read(from: buf), 
            `address`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: AddressInfo, into buf: Writer) {
        FfiConverterUInt32.write(value.`index`, into: buf)
        FfiConverterString.write(value.`address`, into: buf)
    }
}


public struct Balance {
    public var `immature`: UInt64
    public var `trustedPending`: UInt64
    public var `untrustedPending`: UInt64
    public var `confirmed`: UInt64
    public var `spendable`: UInt64
    public var `total`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`immature`: UInt64, `trustedPending`: UInt64, `untrustedPending`: UInt64, `confirmed`: UInt64, `spendable`: UInt64, `total`: UInt64) {
        self.`immature` = `immature`
        self.`trustedPending` = `trustedPending`
        self.`untrustedPending` = `untrustedPending`
        self.`confirmed` = `confirmed`
        self.`spendable` = `spendable`
        self.`total` = `total`
    }
}


extension Balance: Equatable, Hashable {
    public static func ==(lhs: Balance, rhs: Balance) -> Bool {
        if lhs.`immature` != rhs.`immature` {
            return false
        }
        if lhs.`trustedPending` != rhs.`trustedPending` {
            return false
        }
        if lhs.`untrustedPending` != rhs.`untrustedPending` {
            return false
        }
        if lhs.`confirmed` != rhs.`confirmed` {
            return false
        }
        if lhs.`spendable` != rhs.`spendable` {
            return false
        }
        if lhs.`total` != rhs.`total` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`immature`)
        hasher.combine(`trustedPending`)
        hasher.combine(`untrustedPending`)
        hasher.combine(`confirmed`)
        hasher.combine(`spendable`)
        hasher.combine(`total`)
    }
}


fileprivate struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> Balance {
        return try Balance(
            `immature`: FfiConverterUInt64.read(from: buf), 
            `trustedPending`: FfiConverterUInt64.read(from: buf), 
            `untrustedPending`: FfiConverterUInt64.read(from: buf), 
            `confirmed`: FfiConverterUInt64.read(from: buf), 
            `spendable`: FfiConverterUInt64.read(from: buf), 
            `total`: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: Balance, into buf: Writer) {
        FfiConverterUInt64.write(value.`immature`, into: buf)
        FfiConverterUInt64.write(value.`trustedPending`, into: buf)
        FfiConverterUInt64.write(value.`untrustedPending`, into: buf)
        FfiConverterUInt64.write(value.`confirmed`, into: buf)
        FfiConverterUInt64.write(value.`spendable`, into: buf)
        FfiConverterUInt64.write(value.`total`, into: buf)
    }
}


public struct BlockTime {
    public var `height`: UInt32
    public var `timestamp`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt32, `timestamp`: UInt64) {
        self.`height` = `height`
        self.`timestamp` = `timestamp`
    }
}


extension BlockTime: Equatable, Hashable {
    public static func ==(lhs: BlockTime, rhs: BlockTime) -> Bool {
        if lhs.`height` != rhs.`height` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`height`)
        hasher.combine(`timestamp`)
    }
}


fileprivate struct FfiConverterTypeBlockTime: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> BlockTime {
        return try BlockTime(
            `height`: FfiConverterUInt32.read(from: buf), 
            `timestamp`: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: BlockTime, into buf: Writer) {
        FfiConverterUInt32.write(value.`height`, into: buf)
        FfiConverterUInt64.write(value.`timestamp`, into: buf)
    }
}


public struct ElectrumConfig {
    public var `url`: String
    public var `socks5`: String?
    public var `retry`: UInt8
    public var `timeout`: UInt8?
    public var `stopGap`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`url`: String, `socks5`: String?, `retry`: UInt8, `timeout`: UInt8?, `stopGap`: UInt64) {
        self.`url` = `url`
        self.`socks5` = `socks5`
        self.`retry` = `retry`
        self.`timeout` = `timeout`
        self.`stopGap` = `stopGap`
    }
}


extension ElectrumConfig: Equatable, Hashable {
    public static func ==(lhs: ElectrumConfig, rhs: ElectrumConfig) -> Bool {
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`socks5` != rhs.`socks5` {
            return false
        }
        if lhs.`retry` != rhs.`retry` {
            return false
        }
        if lhs.`timeout` != rhs.`timeout` {
            return false
        }
        if lhs.`stopGap` != rhs.`stopGap` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`url`)
        hasher.combine(`socks5`)
        hasher.combine(`retry`)
        hasher.combine(`timeout`)
        hasher.combine(`stopGap`)
    }
}


fileprivate struct FfiConverterTypeElectrumConfig: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> ElectrumConfig {
        return try ElectrumConfig(
            `url`: FfiConverterString.read(from: buf), 
            `socks5`: FfiConverterOptionString.read(from: buf), 
            `retry`: FfiConverterUInt8.read(from: buf), 
            `timeout`: FfiConverterOptionUInt8.read(from: buf), 
            `stopGap`: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: ElectrumConfig, into buf: Writer) {
        FfiConverterString.write(value.`url`, into: buf)
        FfiConverterOptionString.write(value.`socks5`, into: buf)
        FfiConverterUInt8.write(value.`retry`, into: buf)
        FfiConverterOptionUInt8.write(value.`timeout`, into: buf)
        FfiConverterUInt64.write(value.`stopGap`, into: buf)
    }
}


public struct EsploraConfig {
    public var `baseUrl`: String
    public var `proxy`: String?
    public var `concurrency`: UInt8?
    public var `stopGap`: UInt64
    public var `timeout`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`baseUrl`: String, `proxy`: String?, `concurrency`: UInt8?, `stopGap`: UInt64, `timeout`: UInt64?) {
        self.`baseUrl` = `baseUrl`
        self.`proxy` = `proxy`
        self.`concurrency` = `concurrency`
        self.`stopGap` = `stopGap`
        self.`timeout` = `timeout`
    }
}


extension EsploraConfig: Equatable, Hashable {
    public static func ==(lhs: EsploraConfig, rhs: EsploraConfig) -> Bool {
        if lhs.`baseUrl` != rhs.`baseUrl` {
            return false
        }
        if lhs.`proxy` != rhs.`proxy` {
            return false
        }
        if lhs.`concurrency` != rhs.`concurrency` {
            return false
        }
        if lhs.`stopGap` != rhs.`stopGap` {
            return false
        }
        if lhs.`timeout` != rhs.`timeout` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`baseUrl`)
        hasher.combine(`proxy`)
        hasher.combine(`concurrency`)
        hasher.combine(`stopGap`)
        hasher.combine(`timeout`)
    }
}


fileprivate struct FfiConverterTypeEsploraConfig: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> EsploraConfig {
        return try EsploraConfig(
            `baseUrl`: FfiConverterString.read(from: buf), 
            `proxy`: FfiConverterOptionString.read(from: buf), 
            `concurrency`: FfiConverterOptionUInt8.read(from: buf), 
            `stopGap`: FfiConverterUInt64.read(from: buf), 
            `timeout`: FfiConverterOptionUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: EsploraConfig, into buf: Writer) {
        FfiConverterString.write(value.`baseUrl`, into: buf)
        FfiConverterOptionString.write(value.`proxy`, into: buf)
        FfiConverterOptionUInt8.write(value.`concurrency`, into: buf)
        FfiConverterUInt64.write(value.`stopGap`, into: buf)
        FfiConverterOptionUInt64.write(value.`timeout`, into: buf)
    }
}


public struct LocalUtxo {
    public var `outpoint`: OutPoint
    public var `txout`: TxOut
    public var `keychain`: KeychainKind
    public var `isSpent`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`outpoint`: OutPoint, `txout`: TxOut, `keychain`: KeychainKind, `isSpent`: Bool) {
        self.`outpoint` = `outpoint`
        self.`txout` = `txout`
        self.`keychain` = `keychain`
        self.`isSpent` = `isSpent`
    }
}


extension LocalUtxo: Equatable, Hashable {
    public static func ==(lhs: LocalUtxo, rhs: LocalUtxo) -> Bool {
        if lhs.`outpoint` != rhs.`outpoint` {
            return false
        }
        if lhs.`txout` != rhs.`txout` {
            return false
        }
        if lhs.`keychain` != rhs.`keychain` {
            return false
        }
        if lhs.`isSpent` != rhs.`isSpent` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`outpoint`)
        hasher.combine(`txout`)
        hasher.combine(`keychain`)
        hasher.combine(`isSpent`)
    }
}


fileprivate struct FfiConverterTypeLocalUtxo: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> LocalUtxo {
        return try LocalUtxo(
            `outpoint`: FfiConverterTypeOutPoint.read(from: buf), 
            `txout`: FfiConverterTypeTxOut.read(from: buf), 
            `keychain`: FfiConverterTypeKeychainKind.read(from: buf), 
            `isSpent`: FfiConverterBool.read(from: buf)
        )
    }

    fileprivate static func write(_ value: LocalUtxo, into buf: Writer) {
        FfiConverterTypeOutPoint.write(value.`outpoint`, into: buf)
        FfiConverterTypeTxOut.write(value.`txout`, into: buf)
        FfiConverterTypeKeychainKind.write(value.`keychain`, into: buf)
        FfiConverterBool.write(value.`isSpent`, into: buf)
    }
}


public struct OutPoint {
    public var `txid`: String
    public var `vout`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`txid`: String, `vout`: UInt32) {
        self.`txid` = `txid`
        self.`vout` = `vout`
    }
}


extension OutPoint: Equatable, Hashable {
    public static func ==(lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`vout` != rhs.`vout` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`txid`)
        hasher.combine(`vout`)
    }
}


fileprivate struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> OutPoint {
        return try OutPoint(
            `txid`: FfiConverterString.read(from: buf), 
            `vout`: FfiConverterUInt32.read(from: buf)
        )
    }

    fileprivate static func write(_ value: OutPoint, into buf: Writer) {
        FfiConverterString.write(value.`txid`, into: buf)
        FfiConverterUInt32.write(value.`vout`, into: buf)
    }
}


public struct ScriptAmount {
    public var `script`: Script
    public var `amount`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`script`: Script, `amount`: UInt64) {
        self.`script` = `script`
        self.`amount` = `amount`
    }
}



fileprivate struct FfiConverterTypeScriptAmount: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> ScriptAmount {
        return try ScriptAmount(
            `script`: FfiConverterTypeScript.read(from: buf), 
            `amount`: FfiConverterUInt64.read(from: buf)
        )
    }

    fileprivate static func write(_ value: ScriptAmount, into buf: Writer) {
        FfiConverterTypeScript.write(value.`script`, into: buf)
        FfiConverterUInt64.write(value.`amount`, into: buf)
    }
}


public struct SledDbConfiguration {
    public var `path`: String
    public var `treeName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`path`: String, `treeName`: String) {
        self.`path` = `path`
        self.`treeName` = `treeName`
    }
}


extension SledDbConfiguration: Equatable, Hashable {
    public static func ==(lhs: SledDbConfiguration, rhs: SledDbConfiguration) -> Bool {
        if lhs.`path` != rhs.`path` {
            return false
        }
        if lhs.`treeName` != rhs.`treeName` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`path`)
        hasher.combine(`treeName`)
    }
}


fileprivate struct FfiConverterTypeSledDbConfiguration: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> SledDbConfiguration {
        return try SledDbConfiguration(
            `path`: FfiConverterString.read(from: buf), 
            `treeName`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: SledDbConfiguration, into buf: Writer) {
        FfiConverterString.write(value.`path`, into: buf)
        FfiConverterString.write(value.`treeName`, into: buf)
    }
}


public struct SqliteDbConfiguration {
    public var `path`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`path`: String) {
        self.`path` = `path`
    }
}


extension SqliteDbConfiguration: Equatable, Hashable {
    public static func ==(lhs: SqliteDbConfiguration, rhs: SqliteDbConfiguration) -> Bool {
        if lhs.`path` != rhs.`path` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`path`)
    }
}


fileprivate struct FfiConverterTypeSqliteDbConfiguration: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> SqliteDbConfiguration {
        return try SqliteDbConfiguration(
            `path`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: SqliteDbConfiguration, into buf: Writer) {
        FfiConverterString.write(value.`path`, into: buf)
    }
}


public struct TransactionDetails {
    public var `fee`: UInt64?
    public var `received`: UInt64
    public var `sent`: UInt64
    public var `txid`: String
    public var `confirmationTime`: BlockTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`fee`: UInt64?, `received`: UInt64, `sent`: UInt64, `txid`: String, `confirmationTime`: BlockTime?) {
        self.`fee` = `fee`
        self.`received` = `received`
        self.`sent` = `sent`
        self.`txid` = `txid`
        self.`confirmationTime` = `confirmationTime`
    }
}


extension TransactionDetails: Equatable, Hashable {
    public static func ==(lhs: TransactionDetails, rhs: TransactionDetails) -> Bool {
        if lhs.`fee` != rhs.`fee` {
            return false
        }
        if lhs.`received` != rhs.`received` {
            return false
        }
        if lhs.`sent` != rhs.`sent` {
            return false
        }
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`confirmationTime` != rhs.`confirmationTime` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`fee`)
        hasher.combine(`received`)
        hasher.combine(`sent`)
        hasher.combine(`txid`)
        hasher.combine(`confirmationTime`)
    }
}


fileprivate struct FfiConverterTypeTransactionDetails: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> TransactionDetails {
        return try TransactionDetails(
            `fee`: FfiConverterOptionUInt64.read(from: buf), 
            `received`: FfiConverterUInt64.read(from: buf), 
            `sent`: FfiConverterUInt64.read(from: buf), 
            `txid`: FfiConverterString.read(from: buf), 
            `confirmationTime`: FfiConverterOptionTypeBlockTime.read(from: buf)
        )
    }

    fileprivate static func write(_ value: TransactionDetails, into buf: Writer) {
        FfiConverterOptionUInt64.write(value.`fee`, into: buf)
        FfiConverterUInt64.write(value.`received`, into: buf)
        FfiConverterUInt64.write(value.`sent`, into: buf)
        FfiConverterString.write(value.`txid`, into: buf)
        FfiConverterOptionTypeBlockTime.write(value.`confirmationTime`, into: buf)
    }
}


public struct TxBuilderResult {
    public var `psbt`: PartiallySignedTransaction
    public var `transactionDetails`: TransactionDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`psbt`: PartiallySignedTransaction, `transactionDetails`: TransactionDetails) {
        self.`psbt` = `psbt`
        self.`transactionDetails` = `transactionDetails`
    }
}



fileprivate struct FfiConverterTypeTxBuilderResult: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> TxBuilderResult {
        return try TxBuilderResult(
            `psbt`: FfiConverterTypePartiallySignedTransaction.read(from: buf), 
            `transactionDetails`: FfiConverterTypeTransactionDetails.read(from: buf)
        )
    }

    fileprivate static func write(_ value: TxBuilderResult, into buf: Writer) {
        FfiConverterTypePartiallySignedTransaction.write(value.`psbt`, into: buf)
        FfiConverterTypeTransactionDetails.write(value.`transactionDetails`, into: buf)
    }
}


public struct TxOut {
    public var `value`: UInt64
    public var `address`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`value`: UInt64, `address`: String) {
        self.`value` = `value`
        self.`address` = `address`
    }
}


extension TxOut: Equatable, Hashable {
    public static func ==(lhs: TxOut, rhs: TxOut) -> Bool {
        if lhs.`value` != rhs.`value` {
            return false
        }
        if lhs.`address` != rhs.`address` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`value`)
        hasher.combine(`address`)
    }
}


fileprivate struct FfiConverterTypeTxOut: FfiConverterRustBuffer {
    fileprivate static func read(from buf: Reader) throws -> TxOut {
        return try TxOut(
            `value`: FfiConverterUInt64.read(from: buf), 
            `address`: FfiConverterString.read(from: buf)
        )
    }

    fileprivate static func write(_ value: TxOut, into buf: Writer) {
        FfiConverterUInt64.write(value.`value`, into: buf)
        FfiConverterString.write(value.`address`, into: buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AddressIndex {
    
    case `new`
    case `lastUnused`
}

fileprivate struct FfiConverterTypeAddressIndex: FfiConverterRustBuffer {
    typealias SwiftType = AddressIndex

    static func read(from buf: Reader) throws -> AddressIndex {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`new`
        
        case 2: return .`lastUnused`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: AddressIndex, into buf: Writer) {
        switch value {
        
        
        case .`new`:
            buf.writeInt(Int32(1))
        
        
        case .`lastUnused`:
            buf.writeInt(Int32(2))
        
        }
    }
}


extension AddressIndex: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BlockchainConfig {
    
    case `electrum`(`config`: ElectrumConfig)
    case `esplora`(`config`: EsploraConfig)
}

fileprivate struct FfiConverterTypeBlockchainConfig: FfiConverterRustBuffer {
    typealias SwiftType = BlockchainConfig

    static func read(from buf: Reader) throws -> BlockchainConfig {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`electrum`(
            `config`: try FfiConverterTypeElectrumConfig.read(from: buf)
        )
        
        case 2: return .`esplora`(
            `config`: try FfiConverterTypeEsploraConfig.read(from: buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: BlockchainConfig, into buf: Writer) {
        switch value {
        
        
        case let .`electrum`(`config`):
            buf.writeInt(Int32(1))
            FfiConverterTypeElectrumConfig.write(`config`, into: buf)
            
        
        case let .`esplora`(`config`):
            buf.writeInt(Int32(2))
            FfiConverterTypeEsploraConfig.write(`config`, into: buf)
            
        }
    }
}


extension BlockchainConfig: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DatabaseConfig {
    
    case `memory`
    case `sled`(`config`: SledDbConfiguration)
    case `sqlite`(`config`: SqliteDbConfiguration)
}

fileprivate struct FfiConverterTypeDatabaseConfig: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseConfig

    static func read(from buf: Reader) throws -> DatabaseConfig {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`memory`
        
        case 2: return .`sled`(
            `config`: try FfiConverterTypeSledDbConfiguration.read(from: buf)
        )
        
        case 3: return .`sqlite`(
            `config`: try FfiConverterTypeSqliteDbConfiguration.read(from: buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: DatabaseConfig, into buf: Writer) {
        switch value {
        
        
        case .`memory`:
            buf.writeInt(Int32(1))
        
        
        case let .`sled`(`config`):
            buf.writeInt(Int32(2))
            FfiConverterTypeSledDbConfiguration.write(`config`, into: buf)
            
        
        case let .`sqlite`(`config`):
            buf.writeInt(Int32(3))
            FfiConverterTypeSqliteDbConfiguration.write(`config`, into: buf)
            
        }
    }
}


extension DatabaseConfig: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum KeychainKind {
    
    case `external`
    case `internal`
}

fileprivate struct FfiConverterTypeKeychainKind: FfiConverterRustBuffer {
    typealias SwiftType = KeychainKind

    static func read(from buf: Reader) throws -> KeychainKind {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`external`
        
        case 2: return .`internal`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: KeychainKind, into buf: Writer) {
        switch value {
        
        
        case .`external`:
            buf.writeInt(Int32(1))
        
        
        case .`internal`:
            buf.writeInt(Int32(2))
        
        }
    }
}


extension KeychainKind: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case `bitcoin`
    case `testnet`
    case `signet`
    case `regtest`
}

fileprivate struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    static func read(from buf: Reader) throws -> Network {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`bitcoin`
        
        case 2: return .`testnet`
        
        case 3: return .`signet`
        
        case 4: return .`regtest`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: Network, into buf: Writer) {
        switch value {
        
        
        case .`bitcoin`:
            buf.writeInt(Int32(1))
        
        
        case .`testnet`:
            buf.writeInt(Int32(2))
        
        
        case .`signet`:
            buf.writeInt(Int32(3))
        
        
        case .`regtest`:
            buf.writeInt(Int32(4))
        
        }
    }
}


extension Network: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WordCount {
    
    case `words12`
    case `words15`
    case `words18`
    case `words21`
    case `words24`
}

fileprivate struct FfiConverterTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount

    static func read(from buf: Reader) throws -> WordCount {
        let variant: Int32 = try buf.readInt()
        switch variant {
        
        case 1: return .`words12`
        
        case 2: return .`words15`
        
        case 3: return .`words18`
        
        case 4: return .`words21`
        
        case 5: return .`words24`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: WordCount, into buf: Writer) {
        switch value {
        
        
        case .`words12`:
            buf.writeInt(Int32(1))
        
        
        case .`words15`:
            buf.writeInt(Int32(2))
        
        
        case .`words18`:
            buf.writeInt(Int32(3))
        
        
        case .`words21`:
            buf.writeInt(Int32(4))
        
        
        case .`words24`:
            buf.writeInt(Int32(5))
        
        }
    }
}


extension WordCount: Equatable, Hashable {}



public enum BdkError {

    
    
    // Simple error enums only carry a message
    case InvalidU32Bytes(message: String)
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case MissingCachedScripts(message: String)
    
    // Simple error enums only carry a message
    case ScriptDoesntHaveAddressForm(message: String)
    
    // Simple error enums only carry a message
    case NoRecipients(message: String)
    
    // Simple error enums only carry a message
    case NoUtxosSelected(message: String)
    
    // Simple error enums only carry a message
    case OutputBelowDustLimit(message: String)
    
    // Simple error enums only carry a message
    case InsufficientFunds(message: String)
    
    // Simple error enums only carry a message
    case BnBTotalTriesExceeded(message: String)
    
    // Simple error enums only carry a message
    case BnBNoExactMatch(message: String)
    
    // Simple error enums only carry a message
    case UnknownUtxo(message: String)
    
    // Simple error enums only carry a message
    case TransactionNotFound(message: String)
    
    // Simple error enums only carry a message
    case TransactionConfirmed(message: String)
    
    // Simple error enums only carry a message
    case IrreplaceableTransaction(message: String)
    
    // Simple error enums only carry a message
    case FeeRateTooLow(message: String)
    
    // Simple error enums only carry a message
    case FeeTooLow(message: String)
    
    // Simple error enums only carry a message
    case FeeRateUnavailable(message: String)
    
    // Simple error enums only carry a message
    case MissingKeyOrigin(message: String)
    
    // Simple error enums only carry a message
    case Key(message: String)
    
    // Simple error enums only carry a message
    case ChecksumMismatch(message: String)
    
    // Simple error enums only carry a message
    case SpendingPolicyRequired(message: String)
    
    // Simple error enums only carry a message
    case InvalidPolicyPathError(message: String)
    
    // Simple error enums only carry a message
    case Signer(message: String)
    
    // Simple error enums only carry a message
    case InvalidNetwork(message: String)
    
    // Simple error enums only carry a message
    case InvalidProgressValue(message: String)
    
    // Simple error enums only carry a message
    case ProgressUpdateError(message: String)
    
    // Simple error enums only carry a message
    case InvalidOutpoint(message: String)
    
    // Simple error enums only carry a message
    case Descriptor(message: String)
    
    // Simple error enums only carry a message
    case Encode(message: String)
    
    // Simple error enums only carry a message
    case Miniscript(message: String)
    
    // Simple error enums only carry a message
    case MiniscriptPsbt(message: String)
    
    // Simple error enums only carry a message
    case Bip32(message: String)
    
    // Simple error enums only carry a message
    case Secp256k1(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
    // Simple error enums only carry a message
    case Hex(message: String)
    
    // Simple error enums only carry a message
    case Psbt(message: String)
    
    // Simple error enums only carry a message
    case PsbtParse(message: String)
    
    // Simple error enums only carry a message
    case Electrum(message: String)
    
    // Simple error enums only carry a message
    case Esplora(message: String)
    
    // Simple error enums only carry a message
    case Sled(message: String)
    
    // Simple error enums only carry a message
    case Rusqlite(message: String)
    
}

fileprivate struct FfiConverterTypeBdkError: FfiConverterRustBuffer {
    typealias SwiftType = BdkError

    static func read(from buf: Reader) throws -> BdkError {
        let variant: Int32 = try buf.readInt()
        switch variant {

        

        
        case 1: return .InvalidU32Bytes(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 3: return .MissingCachedScripts(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 4: return .ScriptDoesntHaveAddressForm(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 5: return .NoRecipients(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 6: return .NoUtxosSelected(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 7: return .OutputBelowDustLimit(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 8: return .InsufficientFunds(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 9: return .BnBTotalTriesExceeded(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 10: return .BnBNoExactMatch(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 11: return .UnknownUtxo(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 12: return .TransactionNotFound(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 13: return .TransactionConfirmed(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 14: return .IrreplaceableTransaction(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 15: return .FeeRateTooLow(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 16: return .FeeTooLow(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 17: return .FeeRateUnavailable(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 18: return .MissingKeyOrigin(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 19: return .Key(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 20: return .ChecksumMismatch(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 21: return .SpendingPolicyRequired(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 22: return .InvalidPolicyPathError(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 23: return .Signer(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 24: return .InvalidNetwork(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 25: return .InvalidProgressValue(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 26: return .ProgressUpdateError(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 27: return .InvalidOutpoint(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 28: return .Descriptor(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 29: return .Encode(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 30: return .Miniscript(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 31: return .MiniscriptPsbt(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 32: return .Bip32(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 33: return .Secp256k1(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 34: return .Json(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 35: return .Hex(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 36: return .Psbt(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 37: return .PsbtParse(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 38: return .Electrum(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 39: return .Esplora(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 40: return .Sled(
            message: try FfiConverterString.read(from: buf)
        )
        
        case 41: return .Rusqlite(
            message: try FfiConverterString.read(from: buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    static func write(_ value: BdkError, into buf: Writer) {
        switch value {

        

        
        case let .InvalidU32Bytes(message):
            buf.writeInt(Int32(1))
            FfiConverterString.write(message, into: buf)
        case let .Generic(message):
            buf.writeInt(Int32(2))
            FfiConverterString.write(message, into: buf)
        case let .MissingCachedScripts(message):
            buf.writeInt(Int32(3))
            FfiConverterString.write(message, into: buf)
        case let .ScriptDoesntHaveAddressForm(message):
            buf.writeInt(Int32(4))
            FfiConverterString.write(message, into: buf)
        case let .NoRecipients(message):
            buf.writeInt(Int32(5))
            FfiConverterString.write(message, into: buf)
        case let .NoUtxosSelected(message):
            buf.writeInt(Int32(6))
            FfiConverterString.write(message, into: buf)
        case let .OutputBelowDustLimit(message):
            buf.writeInt(Int32(7))
            FfiConverterString.write(message, into: buf)
        case let .InsufficientFunds(message):
            buf.writeInt(Int32(8))
            FfiConverterString.write(message, into: buf)
        case let .BnBTotalTriesExceeded(message):
            buf.writeInt(Int32(9))
            FfiConverterString.write(message, into: buf)
        case let .BnBNoExactMatch(message):
            buf.writeInt(Int32(10))
            FfiConverterString.write(message, into: buf)
        case let .UnknownUtxo(message):
            buf.writeInt(Int32(11))
            FfiConverterString.write(message, into: buf)
        case let .TransactionNotFound(message):
            buf.writeInt(Int32(12))
            FfiConverterString.write(message, into: buf)
        case let .TransactionConfirmed(message):
            buf.writeInt(Int32(13))
            FfiConverterString.write(message, into: buf)
        case let .IrreplaceableTransaction(message):
            buf.writeInt(Int32(14))
            FfiConverterString.write(message, into: buf)
        case let .FeeRateTooLow(message):
            buf.writeInt(Int32(15))
            FfiConverterString.write(message, into: buf)
        case let .FeeTooLow(message):
            buf.writeInt(Int32(16))
            FfiConverterString.write(message, into: buf)
        case let .FeeRateUnavailable(message):
            buf.writeInt(Int32(17))
            FfiConverterString.write(message, into: buf)
        case let .MissingKeyOrigin(message):
            buf.writeInt(Int32(18))
            FfiConverterString.write(message, into: buf)
        case let .Key(message):
            buf.writeInt(Int32(19))
            FfiConverterString.write(message, into: buf)
        case let .ChecksumMismatch(message):
            buf.writeInt(Int32(20))
            FfiConverterString.write(message, into: buf)
        case let .SpendingPolicyRequired(message):
            buf.writeInt(Int32(21))
            FfiConverterString.write(message, into: buf)
        case let .InvalidPolicyPathError(message):
            buf.writeInt(Int32(22))
            FfiConverterString.write(message, into: buf)
        case let .Signer(message):
            buf.writeInt(Int32(23))
            FfiConverterString.write(message, into: buf)
        case let .InvalidNetwork(message):
            buf.writeInt(Int32(24))
            FfiConverterString.write(message, into: buf)
        case let .InvalidProgressValue(message):
            buf.writeInt(Int32(25))
            FfiConverterString.write(message, into: buf)
        case let .ProgressUpdateError(message):
            buf.writeInt(Int32(26))
            FfiConverterString.write(message, into: buf)
        case let .InvalidOutpoint(message):
            buf.writeInt(Int32(27))
            FfiConverterString.write(message, into: buf)
        case let .Descriptor(message):
            buf.writeInt(Int32(28))
            FfiConverterString.write(message, into: buf)
        case let .Encode(message):
            buf.writeInt(Int32(29))
            FfiConverterString.write(message, into: buf)
        case let .Miniscript(message):
            buf.writeInt(Int32(30))
            FfiConverterString.write(message, into: buf)
        case let .MiniscriptPsbt(message):
            buf.writeInt(Int32(31))
            FfiConverterString.write(message, into: buf)
        case let .Bip32(message):
            buf.writeInt(Int32(32))
            FfiConverterString.write(message, into: buf)
        case let .Secp256k1(message):
            buf.writeInt(Int32(33))
            FfiConverterString.write(message, into: buf)
        case let .Json(message):
            buf.writeInt(Int32(34))
            FfiConverterString.write(message, into: buf)
        case let .Hex(message):
            buf.writeInt(Int32(35))
            FfiConverterString.write(message, into: buf)
        case let .Psbt(message):
            buf.writeInt(Int32(36))
            FfiConverterString.write(message, into: buf)
        case let .PsbtParse(message):
            buf.writeInt(Int32(37))
            FfiConverterString.write(message, into: buf)
        case let .Electrum(message):
            buf.writeInt(Int32(38))
            FfiConverterString.write(message, into: buf)
        case let .Esplora(message):
            buf.writeInt(Int32(39))
            FfiConverterString.write(message, into: buf)
        case let .Sled(message):
            buf.writeInt(Int32(40))
            FfiConverterString.write(message, into: buf)
        case let .Rusqlite(message):
            buf.writeInt(Int32(41))
            FfiConverterString.write(message, into: buf)

        
        }
    }
}


extension BdkError: Equatable, Hashable {}

extension BdkError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias Handle = UInt64
fileprivate class ConcurrentHandleMap<T> {
    private var leftMap: [Handle: T] = [:]
    private var counter: [Handle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: Handle] = [:]

    private let lock = NSLock()
    private var currentHandle: Handle = 0
    private let stride: Handle = 1

    func insert(obj: T) -> Handle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: Handle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: Handle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: Handle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for Progress Callback Interface

public protocol Progress : AnyObject {
    func `update`(`progress`: Float, `message`: String?) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceProgress : ForeignCallback =
    { (handle: Handle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeUpdate`(_ swiftCallbackInterface: Progress, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            let reader = Reader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`update`(
                    `progress`:  try FfiConverterFloat.read(from: reader), 
                    `message`:  try FfiConverterOptionString.read(from: reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: Progress
        do {
            cb = try FfiConverterCallbackInterfaceProgress.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("Progress: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceProgress.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FFIConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgress {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_bdk_1cc_Progress_init_callback(foreignCallbackCallbackInterfaceProgress, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: Handle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = ConcurrentHandleMap<Progress>()
}

extension FfiConverterCallbackInterfaceProgress : FfiConverter {
    typealias SwiftType = Progress
    // We can use Handle as the FFIType because it's a typealias to UInt64
    typealias FfiType = Handle

    static func lift(_ handle: Handle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    static func read(from buf: Reader) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: Handle = try buf.readInt()
        return try lift(handle)
    }

    static func lower(_ v: SwiftType) -> Handle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    static func write(_ v: SwiftType, into buf: Writer) {
        ensureCallbackinitialized();
        buf.writeInt(lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterUInt8.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterUInt64.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterString.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFeeRate: FfiConverterRustBuffer {
    typealias SwiftType = FeeRate?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeFeeRate.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRate.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBlockTime: FfiConverterRustBuffer {
    typealias SwiftType = BlockTime?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterTypeBlockTime.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockTime.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceProgress: FfiConverterRustBuffer {
    typealias SwiftType = Progress?

    static func write(_ value: SwiftType, into buf: Writer) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        FfiConverterCallbackInterfaceProgress.write(value, into: buf)
    }

    static func read(from buf: Reader) throws -> SwiftType {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceProgress.read(from: buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: [UInt8], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterUInt8.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [UInt8] {
        let len: Int32 = try buf.readInt()
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocalUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [LocalUtxo]

    static func write(_ value: [LocalUtxo], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeLocalUtxo.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [LocalUtxo] {
        let len: Int32 = try buf.readInt()
        var seq = [LocalUtxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalUtxo.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = [OutPoint]

    static func write(_ value: [OutPoint], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeOutPoint.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [OutPoint] {
        let len: Int32 = try buf.readInt()
        var seq = [OutPoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutPoint.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeScriptAmount: FfiConverterRustBuffer {
    typealias SwiftType = [ScriptAmount]

    static func write(_ value: [ScriptAmount], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeScriptAmount.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [ScriptAmount] {
        let len: Int32 = try buf.readInt()
        var seq = [ScriptAmount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeScriptAmount.read(from: buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransactionDetails: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionDetails]

    static func write(_ value: [TransactionDetails], into buf: Writer) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            FfiConverterTypeTransactionDetails.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> [TransactionDetails] {
        let len: Int32 = try buf.readInt()
        var seq = [TransactionDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionDetails.read(from: buf))
        }
        return seq
    }
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum BdkLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}